<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: quality_control.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: quality_control.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as scran from "scran.js"; 
import * as utils from "./utils/general.js";
import { mito } from "./mito.js";
import * as inputs_module from "./inputs.js";

/**
 * This step applies quality control on the original count matrix.
 * After removing low-quality cells, the filtered matrix is used for all downstream steps.
 * This wraps `computePerCellQCMetrics` and related functions from [**scran.js**](https://github.com/jkanche/scran.js).
 *
 * The parameters in {@linkcode runAnalysis} should be an object containing:
 *
 * - `use_mito_default`: boolean indicating whether the internal mitochondrial gene lists should be used.
 * - `mito_prefix`: string containing the prefix for mitochondrial genes, when `use_mito_default = false`.
 * - `nmads`: number of MADs to use for automatically selecting the filter threshold for each metric.
 *
 * Calling the **`results()`** method for the relevant state instance will return an object containing:
 *
 * - `data`: an object containing one property for each sample.
 *   Each property is itself an object containing `sums`, `detected` and `proportion`,
 *   which are TypedArrays contaning the relevant QC metrics for all cells in that sample.
 * - `thresholds`: an object containing one property for each sample.
 *   Each property is itself an object containing `sums`, `detected` and `proportion`,
 *   which are numbers containing the thresholds on the corresponding QC metrics for that sample.
 * - `retained`: the number of cells remaining after QC filtering.
 * 
 * Methods not documented here are not part of the stable API and should not be used by applications.
 *
 * @namespace quality_control
 */

export class State {
    #inputs;
    #cache;
    #parameters;

    constructor(inputs, parameters = null, cache = null) {
        if (!(inputs instanceof inputs_module.State)) {
            throw new Error("'inputs' should be a State object from './inputs.js'");
        }
        this.#inputs = inputs;

        this.#parameters = (parameters === null ? {} : parameters);
        this.#cache = (cache === null ? {} : cache);
        this.changed = false;
    }

    free() {
        utils.freeCache(this.#cache.metrics);
        utils.freeCache(this.#cache.filters);
        utils.freeCache(this.#cache.matrix);
        utils.freeCache(this.#cache.block_buffer);
        utils.freeCache(this.#cache.metrics_buffer);
    }

    /***************************
     ******** Getters **********
     ***************************/

    fetchSums({ unsafe = false } = {}) {
        // Unsafe, because we're returning a raw view into the Wasm heap,
        // which might be invalidated upon further allocations.
        return this.#cache.metrics.sums({ copy: !unsafe });
    }

    fetchDiscards() {
        return this.#cache.filters.discardOverall({ copy: "view" });
    }

    fetchFilteredMatrix() {
        if (!("matrix" in this.#cache)) {
            this.#apply_filters();
        }
        return this.#cache.matrix;
    }

    fetchFilteredBlock() {
        if (!("blocked" in this.#cache)) {
            this.#apply_filters();
        }
        if (this.#cache.blocked) {
            return this.#cache.block_buffer;
        } else {
            return null;
        }
    }

    fetchFilteredAnnotations(col) { 
        let vec = this.#inputs.fetchAnnotations(col);
        var discard = this.fetchDiscards().array();
        let filterfun = (x, i) => !discard[i];
        if (utils.isObject(vec) &amp;&amp; "index" in vec) {
            vec.index = vec.index.filter(filterfun);
        } else {
            vec = vec.filter(filterfun);
        }
        return vec;
    }

    /***************************
     ******** Compute **********
     ***************************/

    #apply_filters() {
        var mat = this.#inputs.fetchCountMatrix();
        var disc = this.fetchDiscards();

        utils.freeCache(this.#cache.matrix);
        this.#cache.matrix = scran.filterCells(mat, disc);

        let block = this.#inputs.fetchBlock();
        this.#cache.blocked = (block !== null);

        if (this.#cache.blocked) {
            let bcache = utils.allocateCachedArray(this.#cache.matrix.numberOfColumns(), "Int32Array", this.#cache, "block_buffer");

            let bcache_arr = bcache.array();
            let block_arr = block.array();
            let disc_arr = disc.array();
            let j = 0;
            for (let i = 0; i &lt; block_arr.length; i++) {
                if (disc_arr[i] == 0) {
                    bcache_arr[j] = block_arr[i];
                    j++;
                }
            }
        }

        return;
    }

    compute(use_mito_default, mito_prefix, nmads) {
        this.changed = false;

        if (this.#inputs.changed || use_mito_default !== this.#parameters.use_mito_default || mito_prefix !== this.#parameters.mito_prefix) {
            var mat = this.#inputs.fetchCountMatrix();

            // TODO: add more choices.
            var nsubsets = 1;
            var subsets = utils.allocateCachedArray(mat.numberOfRows() * nsubsets, "Uint8Array", this.#cache, "metrics_buffer");
            subsets.fill(0);

            // Finding the prefix.
            // TODO: use the guessed features to narrow the Ensembl/symbol search.
            var gene_info = this.#inputs.fetchGenes();
            var sub_arr = subsets.array();
            for (const [key, val] of Object.entries(gene_info)) {
                if (use_mito_default) {
                    val.forEach((x, i) => {
                        if (mito.symbol.has(x) || mito.ensembl.has(x)) {
                            sub_arr[i] = 1;
                        }
                    });
                } else {
                    var lower_mito = mito_prefix.toLowerCase();
                    val.forEach((x, i) => {
                        if(x.toLowerCase().startsWith(lower_mito)) {
                            sub_arr[i] = 1;
                        }
                    });
                }
            }

            utils.freeCache(this.#cache.metrics);
            this.#cache.metrics = scran.computePerCellQCMetrics(mat, subsets);

            this.#parameters.use_mito_default = use_mito_default;
            this.#parameters.mito_prefix = mito_prefix;
            this.changed = true;
        }

        if (this.changed || nmads !== this.#parameters.nmads) {
            let block = this.#inputs.fetchBlock();
            utils.freeCache(this.#cache.filters);
            this.#cache.filters = scran.computePerCellQCFilters(this.#cache.metrics, { numberOfMADs: nmads, block: block });

            this.#parameters.nmads = nmads;
            this.changed = true;
        }

        if (this.changed) {
            this.#apply_filters();
            this.changed = true; // left in for consistency.
        }

        return;
    }

    /***************************
     ******** Results **********
     ***************************/

    #format_metrics({ copy = true } = {}) {
        copy = (copy ? true : "view");
        return {
            sums: this.#cache.metrics.sums({ copy: copy }),
            detected: this.#cache.metrics.detected({ copy: copy }),
            proportion: this.#cache.metrics.subsetProportions(0, { copy: copy })
        };
    }

    #format_thresholds({ copy = true } = {}) {
        copy = (copy ? true : "view");
        return {
            sums: this.#cache.filters.thresholdsSums({ copy: copy }),
            detected: this.#cache.filters.thresholdsDetected({ copy: copy }),
            proportion: this.#cache.filters.thresholdsSubsetProportions(0, { copy: copy })
        }
    }

    results() {
        // This function should not do any Wasm allocations, so copy: false is safe.

        var data = {};
        var blocks = this.#inputs.fetchBlockLevels();
        if (blocks === null) {
            blocks = [ "default" ];
            data["default"] = this.#format_metrics();
        } else {
            let metrics = this.#format_metrics({ copy: false });
            let bids = this.#inputs.fetchBlock();
            let barray = bids.array();

            for (var b = 0; b &lt; blocks.length; b++) {
                let current = {};
                for (const [key, val] of Object.entries(metrics)) {
                    current[key] = val.array().filter((x, i) => barray[i] == b);
                }
                data[blocks[b]] = current;
            }
        }

        var thresholds = {};
        let listed = this.#format_thresholds({ copy: false });
        for (var b = 0; b &lt; blocks.length; b++) {
            let current = {};
            for (const [key, val] of Object.entries(listed)) {
                current[key] = val[b];
            }
            thresholds[blocks[b]] = current;
        }

        var ranges = {};
        for (var b = 0; b &lt; blocks.length; b++) {
            let curranges = {};
            let curdata = data[blocks[b]];

            for (const [key, val] of Object.entries(curdata)) {
                var max = -Infinity, min = Infinity;
                val.forEach(function (x) {
                    if (max &lt; x) {
                        max = x;
                    }
                    if (min > x) {
                        min = x;
                    }
                });
                curranges[key] = [min, max];
            }

            ranges[blocks[b]] = curranges;
        }

        let remaining = 0;
        if ("matrix" in this.#cache) {
            remaining = this.#cache.matrix.numberOfColumns();
        } else {
            this.fetchDiscards().array().forEach(x => {
                if (x == 0) {
                    remaining++;
                }
            });
        }

        return { 
            "data": data, 
            "ranges": ranges,
            "thresholds": thresholds,
            "retained": remaining
        };
    }

    /*************************
     ******** Saving *********
     *************************/

    serialize(handle) {
        let ghandle = handle.createGroup("quality_control");

        {
            let phandle = ghandle.createGroup("parameters"); 
            phandle.writeDataSet("use_mito_default", "Uint8", [], Number(this.#parameters.use_mito_default));
            phandle.writeDataSet("mito_prefix", "String", [], this.#parameters.mito_prefix);
            phandle.writeDataSet("nmads", "Float64", [], this.#parameters.nmads);
        }

        {
            let rhandle = ghandle.createGroup("results"); 

            {
                let mhandle = rhandle.createGroup("metrics");
                let data = this.#format_metrics({ copy: false });
                mhandle.writeDataSet("sums", "Float64", null, data.sums)
                mhandle.writeDataSet("detected", "Int32", null, data.detected);
                mhandle.writeDataSet("proportion", "Float64", null, data.proportion);
            }

            {
                let thandle = rhandle.createGroup("thresholds");
                let thresholds = this.#format_thresholds({ copy: false });
                for (const x of [ "sums", "detected", "proportion" ]) {
                    let current = thresholds[x];
                    thandle.writeDataSet(x, "Float64", null, current);
                }
            }

            let disc = this.fetchDiscards();
            rhandle.writeDataSet("discards", "Uint8", null, disc);
        }
    }
}

/**************************
 ******** Loading *********
 **************************/

class QCFiltersMimic {
    constructor(sums, detected, proportion, discards) {
        this.sums_ = sums;
        this.detected_ = detected;
        this.proportion_ = proportion;
        this.discards = scran.createUint8WasmArray(discards.length);
        this.discards.set(discards);
    }

    thresholdsSums({ copy }) {
        return utils.mimicGetter(this.sums_, copy);
    }

    thresholdsDetected({ copy }) {
        return utils.mimicGetter(this.detected_, copy);
    }

    thresholdsSubsetProportions(index, { copy }) {
        if (index != 0) {
            throw "only 'index = 0' is supported for mimics";
        }
        return utils.mimicGetter(this.proportion_, copy);
    }

    discardOverall({ copy }) {
        return utils.mimicGetter(this.discards, copy);
    }

    free() {
        this.discards.free();
    }
}

export function unserialize(handle, inputs) {
    let ghandle = handle.open("quality_control");

    let parameters = {};
    {
        let phandle = ghandle.open("parameters"); 
        parameters = {
            use_mito_default: phandle.open("use_mito_default", { load: true }).values[0] > 0,
            mito_prefix: phandle.open("mito_prefix", { load: true }).values[0],
            nmads: phandle.open("nmads", { load: true }).values[0]
        }
    }

    let cache = {};
    {
        let rhandle = ghandle.open("results");

        let mhandle = rhandle.open("metrics");
        let sums = mhandle.open("sums", { load: true }).values;

        cache.metrics = scran.emptyPerCellQCMetricsResults(sums.length, 1);
        cache.metrics.sums({ copy: false }).set(sums);

        let detected = mhandle.open("detected", { load: true }).values;
        cache.metrics.detected({ copy: false }).set(detected);
        let proportions = mhandle.open("proportion", { load: true }).values;
        cache.metrics.subsetProportions(0, { copy: false }).set(proportions);

        let thandle = rhandle.open("thresholds");
        let thresholds_sums = thandle.open("sums", { load: true }).values;
        let thresholds_detected = thandle.open("detected", { load: true }).values;
        let thresholds_proportion = thandle.open("proportion", { load: true }).values;

        let discards = rhandle.open("discards", { load: true }).values; 
        cache.filters = new QCFiltersMimic(
            thresholds_sums, 
            thresholds_detected,
            thresholds_proportion,
            discards
        );
    }

    return {
        state: new State(inputs, parameters, cache),
        parameters: { ...parameters }
    };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="cell_labelling.html">cell_labelling</a></li><li><a href="choose_clustering.html">choose_clustering</a></li><li><a href="custom_selections.html">custom_selections</a></li><li><a href="feature_selection.html">feature_selection</a></li><li><a href="inputs.html">inputs</a></li><li><a href="kmeans_cluster.html">kmeans_cluster</a></li><li><a href="marker_detection.html">marker_detection</a></li><li><a href="neighbor_index.html">neighbor_index</a></li><li><a href="normalization.html">normalization</a></li><li><a href="pca.html">pca</a></li><li><a href="quality_control.html">quality_control</a></li><li><a href="snn_graph_cluster.html">snn_graph_cluster</a></li><li><a href="tsne.html">tsne</a></li><li><a href="umap.html">umap</a></li></ul><h3>Global</h3><ul><li><a href="global.html#analysisDefaults">analysisDefaults</a></li><li><a href="global.html#availableReaders">availableReaders</a></li><li><a href="global.html#createAnalysis">createAnalysis</a></li><li><a href="global.html#createKanaFile">createKanaFile</a></li><li><a href="global.html#freeAnalysis">freeAnalysis</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#loadAnalysis">loadAnalysis</a></li><li><a href="global.html#parseKanaFile">parseKanaFile</a></li><li><a href="global.html#runAnalysis">runAnalysis</a></li><li><a href="global.html#saveAnalysis">saveAnalysis</a></li><li><a href="global.html#setCellLabellingDownload">setCellLabellingDownload</a></li><li><a href="global.html#setCreateLink">setCreateLink</a></li><li><a href="global.html#setResolveLink">setResolveLink</a></li><li><a href="global.html#setVisualizationAnimate">setVisualizationAnimate</a></li><li><a href="global.html#terminate">terminate</a></li><li><a href="global.html#validateAnnotations">validateAnnotations</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Thu Apr 07 2022 16:53:54 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
